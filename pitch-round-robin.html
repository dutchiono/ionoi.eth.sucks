<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Round robin board for a Pitch tournament.">
  <link rel="stylesheet" href="style.css">
  <title>Pitch</title>
</head>
<body class="pitch-theme">
  <div class="page">
    <nav class="top-nav">
      <a class="logo" href="index.html"><img src="dutchgif.gif" alt="dutch" class="logo-gif"></a>
      <div class="tab-links">
        <a class="tab" href="index.html">Home</a>
        <a class="tab active" href="pitch-round-robin.html">Pitch</a>
      </div>
    </nav>

    <main class="content">
      <section class="section">
        <header class="page-heading">
          <h1 class="pitch-title">
            Pitch
            <span class="pitch-suits" aria-hidden="true">
              <span class="pitch-suit pitch-suit-spade">♠</span>
              <span class="pitch-suit pitch-suit-heart">♥</span>
              <span class="pitch-suit pitch-suit-diamond">♦</span>
              <span class="pitch-suit pitch-suit-club">♣</span>
            </span>
          </h1>
        </header>
        <p class="lead">Enter teams + players, auto-generate a round robin schedule, and record scores. Everything saves locally in your browser.</p>
        <div class="rr-row rr-row-wrap rr-row-gap" style="margin-top: 1.25rem;">
          <div class="rr-field rr-grow">
            <label for="tournamentName">Tournament name</label>
            <input id="tournamentName" type="text" placeholder="e.g. Friday Night Pitch" autocomplete="off">
          </div>
        </div>
        <p id="tournamentHint" class="rr-hint"></p>
      </section>

      <section class="section">
        <div class="rr-row rr-between rr-row-wrap rr-row-gap">
          <div>
            <h2 class="rr-h2">GitHub Sync</h2>
            <p class="rr-hint">Optional. Sync this tournament across devices via a GitHub Gist file. Writing requires a GitHub token with <strong>gist</strong> permission.</p>
          </div>
          <div class="rr-row rr-actions">
            <button id="syncPullBtn" class="rr-btn">Pull</button>
            <button id="syncPushBtn" class="rr-btn rr-btn-primary">Push</button>
            <button id="syncCreateBtn" class="rr-btn rr-btn-warn">Create gist</button>
          </div>
        </div>

        <div class="rr-row rr-row-wrap rr-row-gap rr-sync-grid">
          <div class="rr-field rr-grow">
            <label for="syncGistId">Gist ID</label>
            <input id="syncGistId" type="text" placeholder="e.g. 0123456789abcdef..." autocomplete="off">
          </div>
          <div class="rr-field rr-grow">
            <label for="syncFileName">File name (inside gist)</label>
            <input id="syncFileName" type="text" placeholder="pitch.json" autocomplete="off">
          </div>
          <div class="rr-field rr-grow">
            <label for="syncToken">GitHub token (stored in this browser)</label>
            <input id="syncToken" type="password" placeholder="ghp_..." autocomplete="off">
          </div>
        </div>

        <div class="rr-row rr-row-wrap rr-row-gap rr-between">
          <div class="rr-row rr-row-wrap rr-row-gap">
            <label class="rr-check">
              <input id="syncLiveToggle" type="checkbox">
              <span>Live updates (poll)</span>
            </label>
            <div class="rr-field rr-sync-interval">
              <label for="syncInterval">Poll (seconds)</label>
              <input id="syncInterval" type="number" min="3" step="1" value="8">
            </div>
          </div>
          <div id="syncStatus" class="rr-hint"></div>
        </div>
      </section>

      <section class="section">
        <div class="rr-row rr-row-wrap rr-row-gap rr-between">
          <div>
            <h2 class="rr-h2">Teams</h2>
            <p class="rr-hint">Add teams, then click “Generate schedule”. Players are optional.</p>
          </div>
          <div class="rr-row rr-actions">
            <button id="addTeamBtn" class="rr-btn">Add team</button>
            <button id="generateBtn" class="rr-btn rr-btn-primary">Generate schedule</button>
            <button id="resetResultsBtn" class="rr-btn rr-btn-warn">Reset results</button>
          </div>
        </div>

        <div id="teamsContainer" class="rr-team-list"></div>
      </section>

      <section class="section">
        <div class="rr-row rr-between rr-row-wrap rr-row-gap">
          <div>
            <h2 class="rr-h2">Next match</h2>
            <p class="rr-hint">The next unplayed matchup in the schedule.</p>
          </div>
        </div>

        <div id="nextMatchCard" class="rr-card rr-card-muted">
          <div class="rr-hint">Generate a schedule to see the next matchup.</div>
        </div>
      </section>

      <section class="section">
        <div class="rr-row rr-between rr-row-wrap rr-row-gap">
          <div>
            <h2 class="rr-h2">Standings</h2>
            <p class="rr-hint">Wins/Losses are based on recorded match scores.</p>
          </div>
        </div>

        <div class="rr-table-wrap">
          <table class="rr-table" id="standingsTable">
            <thead>
              <tr>
                <th>Team</th>
                <th>GP</th>
                <th>W</th>
                <th>L</th>
                <th>PF</th>
                <th>PA</th>
                <th>Diff</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="section">
        <div class="rr-row rr-between rr-row-wrap rr-row-gap">
          <div>
            <h2 class="rr-h2">Schedule + Scores</h2>
            <p class="rr-hint">Enter scores per matchup. Ties are allowed (no win/loss recorded).</p>
          </div>
        </div>

        <div id="scheduleContainer"></div>
      </section>
    </main>

    <footer class="footer">
      <p>© 2026</p>
    </footer>
  </div>

  <script>
    /**
     * Pitch Round Robin — single-file, no deps.
     * Data persists in localStorage under STORAGE_KEY.
     */
    const STORAGE_KEY_V1 = "pitch_round_robin:v1";
    const STORAGE_KEY = "pitch_round_robin:v2";
    const SYNC_KEY = "pitch_round_robin:sync:v1";

    function nowIso() {
      return new Date().toISOString();
    }

    function uid() {
      // Short, deterministic-enough local id
      return Math.random().toString(36).slice(2, 10) + "-" + Date.now().toString(36);
    }

    function clampInt(val, fallback = 0) {
      if (val === "" || val === null || typeof val === "undefined") return fallback;
      const n = Number(val);
      if (!Number.isFinite(n)) return fallback;
      return Math.trunc(n);
    }

    function safeText(s) {
      return (s ?? "").toString();
    }

    function parsePlayers(str) {
      return safeText(str)
        .split(/[\n,]+/g)
        .map(s => s.trim())
        .filter(Boolean)
        .slice(0, 12);
    }

    function formatPlayers(players) {
      return (players || []).join(", ");
    }

    function migrateV1ToV2(v1) {
      if (!v1 || typeof v1 !== "object") return null;
      const tournaments = Array.isArray(v1.tournaments) ? v1.tournaments : [];
      if (tournaments.length === 0) return null;
      const active = v1.activeId ? (tournaments.find(t => t.id === v1.activeId) || null) : null;
      const picked = active || tournaments[0] || null;
      if (!picked) return null;
      return { tournament: picked };
    }

    function loadState() {
      try {
        const rawV2 = localStorage.getItem(STORAGE_KEY);
        if (rawV2) {
          const parsed = JSON.parse(rawV2);
          if (parsed && typeof parsed === "object" && parsed.tournament && typeof parsed.tournament === "object") {
            return { tournament: parsed.tournament };
          }
        }

        const rawV1 = localStorage.getItem(STORAGE_KEY_V1);
        if (rawV1) {
          const parsedV1 = JSON.parse(rawV1);
          const migrated = migrateV1ToV2(parsedV1);
          if (migrated) return migrated;
        }

        return { tournament: defaultTournament() };
      } catch {
        return { tournament: defaultTournament() };
      }
    }

    function saveState(state) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function loadSyncSettings() {
      try {
        const raw = localStorage.getItem(SYNC_KEY);
        if (!raw) {
          return { gistId: "", token: "", fileName: "pitch.json", live: false, intervalSec: 8, lastRemoteUpdatedAt: "" };
        }
        const parsed = JSON.parse(raw);
        return {
          gistId: safeText(parsed.gistId || ""),
          token: safeText(parsed.token || ""),
          fileName: safeText(parsed.fileName || "pitch.json") || "pitch.json",
          live: Boolean(parsed.live),
          intervalSec: Math.max(3, clampInt(parsed.intervalSec, 8)),
          lastRemoteUpdatedAt: safeText(parsed.lastRemoteUpdatedAt || ""),
        };
      } catch {
        return { gistId: "", token: "", fileName: "pitch.json", live: false, intervalSec: 8, lastRemoteUpdatedAt: "" };
      }
    }

    function saveSyncSettings(settings) {
      localStorage.setItem(SYNC_KEY, JSON.stringify(settings));
    }

    function defaultTournament() {
      return {
        id: uid(),
        name: "Pitch Round Robin",
        createdAt: nowIso(),
        updatedAt: nowIso(),
        teams: [
          { id: uid(), name: "Team A", players: ["Player 1", "Player 2"] },
          { id: uid(), name: "Team B", players: ["Player 3", "Player 4"] },
        ],
        schedule: [],
        results: {}, // matchId -> { aScore, bScore, completedAt }
      };
    }

    function teamNameById(tournament, teamId) {
      return tournament.teams.find(t => t.id === teamId)?.name || "Unknown";
    }

    function matchIdFor(match) {
      return `${match.round}:${match.aId}:${match.bId}`;
    }

    // Standard circle method (a.k.a. Berger tables)
    function generateRoundRobin(teamIds) {
      const ids = [...teamIds];
      if (ids.length < 2) return [];
      if (ids.length % 2 === 1) ids.push(null); // BYE

      const n = ids.length;
      const rounds = n - 1;
      const perRound = n / 2;
      let arr = [...ids];
      const schedule = [];

      for (let r = 0; r < rounds; r++) {
        for (let i = 0; i < perRound; i++) {
          const left = arr[i];
          const right = arr[n - 1 - i];
          if (left === null || right === null) continue;

          // Alternate home/away each round for a bit of fairness
          const swap = (r % 2 === 1) && (i === 0);
          const aId = swap ? right : left;
          const bId = swap ? left : right;

          schedule.push({ round: r + 1, aId, bId });
        }

        // Rotate all but the first element
        // [0, 1, 2, 3, 4, 5] -> [0, 5, 1, 2, 3, 4]
        arr = [arr[0], arr[n - 1], ...arr.slice(1, n - 1)];
      }

      return schedule;
    }

    function computeStandings(tournament) {
      const base = new Map();
      for (const team of tournament.teams) {
        base.set(team.id, {
          teamId: team.id,
          teamName: team.name,
          gp: 0,
          w: 0,
          l: 0,
          pf: 0,
          pa: 0,
        });
      }

      for (const match of tournament.schedule) {
        const id = matchIdFor(match);
        const res = tournament.results[id];
        if (!res) continue;

        const a = base.get(match.aId);
        const b = base.get(match.bId);
        if (!a || !b) continue;

        a.gp += 1;
        b.gp += 1;
        a.pf += res.aScore;
        a.pa += res.bScore;
        b.pf += res.bScore;
        b.pa += res.aScore;

        if (res.aScore > res.bScore) {
          a.w += 1;
          b.l += 1;
        } else if (res.bScore > res.aScore) {
          b.w += 1;
          a.l += 1;
        }
      }

      const rows = [...base.values()].map(r => ({ ...r, diff: r.pf - r.pa }));
      rows.sort((x, y) => {
        if (y.w !== x.w) return y.w - x.w;
        if (y.diff !== x.diff) return y.diff - x.diff;
        if (y.pf !== x.pf) return y.pf - x.pf;
        return x.teamName.localeCompare(y.teamName);
      });
      return rows;
    }

    function nextMatch(tournament) {
      for (const match of tournament.schedule) {
        const id = matchIdFor(match);
        if (!tournament.results[id]) return match;
      }
      return null;
    }

    // ---------- UI ----------
    const els = {
      syncGistId: document.getElementById("syncGistId"),
      syncFileName: document.getElementById("syncFileName"),
      syncToken: document.getElementById("syncToken"),
      syncPullBtn: document.getElementById("syncPullBtn"),
      syncPushBtn: document.getElementById("syncPushBtn"),
      syncCreateBtn: document.getElementById("syncCreateBtn"),
      syncLiveToggle: document.getElementById("syncLiveToggle"),
      syncInterval: document.getElementById("syncInterval"),
      syncStatus: document.getElementById("syncStatus"),
      tournamentName: document.getElementById("tournamentName"),
      tournamentHint: document.getElementById("tournamentHint"),
      addTeamBtn: document.getElementById("addTeamBtn"),
      generateBtn: document.getElementById("generateBtn"),
      resetResultsBtn: document.getElementById("resetResultsBtn"),
      teamsContainer: document.getElementById("teamsContainer"),
      nextMatchCard: document.getElementById("nextMatchCard"),
      standingsBody: document.querySelector("#standingsTable tbody"),
      scheduleContainer: document.getElementById("scheduleContainer"),
    };

    let state = loadState();
    let sync = loadSyncSettings();
    let liveTimer = null;
    let liveInFlight = false;

    if (!state.tournament) {
      state.tournament = defaultTournament();
      saveState(state);
    }

    function persistTournament(tournament) {
      tournament.updatedAt = nowIso();
      state.tournament = tournament;
      saveState(state);
    }

    function setSyncStatus(msg) {
      els.syncStatus.textContent = msg;
    }

    function applySyncSettingsToUI() {
      els.syncGistId.value = sync.gistId || "";
      els.syncFileName.value = sync.fileName || "pitch.json";
      els.syncToken.value = sync.token || "";
      els.syncLiveToggle.checked = Boolean(sync.live);
      els.syncInterval.value = String(sync.intervalSec || 8);
      const gistText = sync.gistId ? `Gist: ${sync.gistId}` : "No gist configured.";
      const remoteText = sync.lastRemoteUpdatedAt ? `Remote updated: ${new Date(sync.lastRemoteUpdatedAt).toLocaleString()}` : "Remote not fetched yet.";
      setSyncStatus(`${gistText} · ${remoteText}`);
    }

    function githubHeaders(token) {
      const headers = {
        "Accept": "application/vnd.github+json",
      };
      if (token) headers["Authorization"] = `Bearer ${token}`;
      return headers;
    }

    async function fetchGist(gistId, token) {
      const res = await fetch(`https://api.github.com/gists/${encodeURIComponent(gistId)}`, {
        method: "GET",
        headers: githubHeaders(token),
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GitHub GET gist failed (${res.status}): ${text}`);
      }
      return await res.json();
    }

    function extractGistFileContent(gistJson, fileName) {
      const files = gistJson?.files || {};
      const file = files[fileName] || null;
      if (!file) {
        const available = Object.keys(files);
        throw new Error(`Gist does not contain "${fileName}". Available: ${available.length ? available.join(", ") : "(none)"}`);
      }
      const content = file.content;
      if (typeof content !== "string") throw new Error(`Gist file "${fileName}" has no readable content.`);
      return content;
    }

    function validateRemoteState(remote) {
      if (!remote || typeof remote !== "object") return false;
      // v2: { tournament: {...} }
      if (remote.tournament && typeof remote.tournament === "object") return true;
      // v1: { activeId, tournaments: [...] }
      if (Array.isArray(remote.tournaments)) return true;
      return false;
    }

    function coerceRemoteToV2(remote) {
      if (remote?.tournament && typeof remote.tournament === "object") {
        return { tournament: remote.tournament };
      }
      const migrated = migrateV1ToV2(remote);
      if (migrated) return migrated;
      return { tournament: defaultTournament() };
    }

    async function syncPull({ quiet = false } = {}) {
      if (!sync.gistId) {
        if (!quiet) alert("Set a Gist ID to pull from.");
        return;
      }
      const gist = await fetchGist(sync.gistId, sync.token);
      const content = extractGistFileContent(gist, sync.fileName || "pitch.json");
      const remote = JSON.parse(content);
      if (!validateRemoteState(remote)) throw new Error("Remote file JSON is not a valid Pitch state object.");

      state = coerceRemoteToV2(remote);
      saveState(state);

      sync.lastRemoteUpdatedAt = safeText(gist.updated_at || "");
      saveSyncSettings(sync);
      rerender();
      applySyncSettingsToUI();
    }

    async function syncPush() {
      if (!sync.gistId) {
        alert("No Gist ID set. Click “Create gist” first, or paste an existing Gist ID.");
        return;
      }
      if (!sync.token) {
        alert("A GitHub token with gist permission is required to push.");
        return;
      }

      // Fetch remote first for conflict detection
      const gist = await fetchGist(sync.gistId, sync.token);
      const remoteUpdatedAt = safeText(gist.updated_at || "");
      if (sync.lastRemoteUpdatedAt && remoteUpdatedAt && sync.lastRemoteUpdatedAt !== remoteUpdatedAt) {
        const proceed = confirm("Remote gist changed since your last pull. Push anyway (may overwrite remote changes)?");
        if (!proceed) return;
      }

      const fileName = sync.fileName || "pitch.json";
      const body = {
        files: {
          [fileName]: { content: JSON.stringify(state, null, 2) },
        },
      };

      const res = await fetch(`https://api.github.com/gists/${encodeURIComponent(sync.gistId)}`, {
        method: "PATCH",
        headers: {
          ...githubHeaders(sync.token),
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GitHub PATCH gist failed (${res.status}): ${text}`);
      }

      const updated = await res.json();
      sync.lastRemoteUpdatedAt = safeText(updated.updated_at || "");
      saveSyncSettings(sync);
      applySyncSettingsToUI();
    }

    async function syncCreateGist() {
      if (!sync.token) {
        alert("A GitHub token with gist permission is required to create a gist.");
        return;
      }
      const fileName = sync.fileName || "pitch.json";
      const body = {
        description: "Pitch tournament data (round robin board)",
        public: false,
        files: {
          [fileName]: { content: JSON.stringify(state, null, 2) },
        },
      };

      const res = await fetch("https://api.github.com/gists", {
        method: "POST",
        headers: {
          ...githubHeaders(sync.token),
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GitHub POST gist failed (${res.status}): ${text}`);
      }

      const created = await res.json();
      sync.gistId = safeText(created.id || "");
      sync.lastRemoteUpdatedAt = safeText(created.updated_at || "");
      saveSyncSettings(sync);
      applySyncSettingsToUI();
      alert(`Gist created. Share this Gist ID with others so they can pull the same data:\n\n${sync.gistId}`);
    }

    function clearLiveTimer() {
      if (liveTimer) {
        clearInterval(liveTimer);
        liveTimer = null;
      }
    }

    function configureLiveUpdates() {
      clearLiveTimer();
      if (!sync.live) return;
      const intervalMs = Math.max(3000, (sync.intervalSec || 8) * 1000);
      liveTimer = setInterval(async () => {
        if (!sync.gistId) return;
        if (liveInFlight) return;
        liveInFlight = true;
        try {
          const gist = await fetchGist(sync.gistId, sync.token);
          const remoteUpdatedAt = safeText(gist.updated_at || "");
          if (sync.lastRemoteUpdatedAt && remoteUpdatedAt && remoteUpdatedAt === sync.lastRemoteUpdatedAt) return;
          await syncPull({ quiet: true });
        } catch (e) {
          // Keep polling; surface last error
          setSyncStatus(`Live update error: ${safeText(e?.message || e)}`);
        } finally {
          liveInFlight = false;
        }
      }, intervalMs);
    }

    function renderTournamentHeader(tournament) {
      els.tournamentName.value = tournament.name || "";
      const updated = tournament.updatedAt ? new Date(tournament.updatedAt).toLocaleString() : "";
      const created = tournament.createdAt ? new Date(tournament.createdAt).toLocaleString() : "";
      els.tournamentHint.textContent = `Created: ${created} · Updated: ${updated} · Teams: ${tournament.teams.length} · Matches: ${tournament.schedule.length}`;
    }

    function renderTeams(tournament) {
      els.teamsContainer.innerHTML = "";
      if (tournament.teams.length === 0) {
        const empty = document.createElement("div");
        empty.className = "rr-card rr-card-muted";
        empty.textContent = "No teams yet. Click “Add team”.";
        els.teamsContainer.appendChild(empty);
        return;
      }

      tournament.teams.forEach((team, idx) => {
        const card = document.createElement("div");
        card.className = "rr-card";

        const top = document.createElement("div");
        top.className = "rr-row rr-between rr-row-gap rr-row-wrap";

        const left = document.createElement("div");
        left.className = "rr-grow";

        const nameLabel = document.createElement("label");
        nameLabel.textContent = `Team ${idx + 1} name`;
        nameLabel.setAttribute("for", `team-name-${team.id}`);
        const nameInput = document.createElement("input");
        nameInput.id = `team-name-${team.id}`;
        nameInput.type = "text";
        nameInput.value = team.name || "";
        nameInput.placeholder = "Team name";
        nameInput.autocomplete = "off";
        nameInput.addEventListener("input", () => {
          team.name = nameInput.value;
          persistTournament(tournament);
          renderTournamentSelect();
          renderTournamentHeader(tournament);
          renderStandings(tournament);
          renderNextMatch(tournament);
          renderSchedule(tournament);
        });

        left.appendChild(nameLabel);
        left.appendChild(nameInput);

        const right = document.createElement("div");
        right.className = "rr-row rr-actions";

        const removeBtn = document.createElement("button");
        removeBtn.className = "rr-btn rr-btn-danger";
        removeBtn.textContent = "Remove";
        removeBtn.addEventListener("click", () => {
          tournament.teams = tournament.teams.filter(t => t.id !== team.id);
          // If teams change, schedule/results might be invalid. Clear them.
          tournament.schedule = [];
          tournament.results = {};
          persistTournament(tournament);
          rerender();
        });

        right.appendChild(removeBtn);
        top.appendChild(left);
        top.appendChild(right);

        const playersLabel = document.createElement("label");
        playersLabel.textContent = "Players (comma or newline separated)";
        playersLabel.setAttribute("for", `team-players-${team.id}`);
        const players = document.createElement("textarea");
        players.id = `team-players-${team.id}`;
        players.rows = 2;
        players.placeholder = "e.g. Alice, Bob";
        players.value = formatPlayers(team.players);
        players.addEventListener("input", () => {
          team.players = parsePlayers(players.value);
          persistTournament(tournament);
          renderNextMatch(tournament);
        });

        card.appendChild(top);
        card.appendChild(playersLabel);
        card.appendChild(players);

        els.teamsContainer.appendChild(card);
      });
    }

    function renderNextMatch(tournament) {
      const match = nextMatch(tournament);
      els.nextMatchCard.innerHTML = "";

      if (!match) {
        const done = document.createElement("div");
        done.className = "rr-hint";
        done.textContent = tournament.schedule.length ? "All matches completed." : "Generate a schedule to see the next matchup.";
        els.nextMatchCard.className = "rr-card rr-card-muted";
        els.nextMatchCard.appendChild(done);
        return;
      }

      els.nextMatchCard.className = "rr-card";

      const aTeam = tournament.teams.find(t => t.id === match.aId);
      const bTeam = tournament.teams.find(t => t.id === match.bId);
      const title = document.createElement("div");
      title.className = "rr-next-title";
      title.textContent = `Round ${match.round}: ${aTeam?.name || "Unknown"} vs ${bTeam?.name || "Unknown"}`;

      const players = document.createElement("div");
      players.className = "rr-hint";
      const aPlayers = (aTeam?.players || []).length ? ` (${(aTeam.players || []).join(", ")})` : "";
      const bPlayers = (bTeam?.players || []).length ? ` (${(bTeam.players || []).join(", ")})` : "";
      players.textContent = `${aTeam?.name || "Unknown"}${aPlayers} · ${bTeam?.name || "Unknown"}${bPlayers}`;

      const row = document.createElement("div");
      row.className = "rr-row rr-row-wrap rr-row-gap rr-between";

      const left = document.createElement("div");
      left.className = "rr-row rr-row-wrap rr-row-gap rr-grow";

      const aField = document.createElement("div");
      aField.className = "rr-field";
      const aLabel = document.createElement("label");
      aLabel.textContent = `${aTeam?.name || "Team A"} score`;
      const aScore = document.createElement("input");
      aScore.type = "number";
      aScore.inputMode = "numeric";
      aScore.placeholder = "0";
      aScore.value = "";
      aField.appendChild(aLabel);
      aField.appendChild(aScore);

      const bField = document.createElement("div");
      bField.className = "rr-field";
      const bLabel = document.createElement("label");
      bLabel.textContent = `${bTeam?.name || "Team B"} score`;
      const bScore = document.createElement("input");
      bScore.type = "number";
      bScore.inputMode = "numeric";
      bScore.placeholder = "0";
      bScore.value = "";
      bField.appendChild(bLabel);
      bField.appendChild(bScore);

      left.appendChild(aField);
      left.appendChild(bField);

      const right = document.createElement("div");
      right.className = "rr-row rr-actions";

      const saveBtn = document.createElement("button");
      saveBtn.className = "rr-btn rr-btn-primary";
      saveBtn.textContent = "Record result";
      saveBtn.addEventListener("click", () => {
        const id = matchIdFor(match);
        tournament.results[id] = {
          aScore: clampInt(aScore.value, 0),
          bScore: clampInt(bScore.value, 0),
          completedAt: nowIso(),
        };
        persistTournament(tournament);
        rerender();
      });

      right.appendChild(saveBtn);

      row.appendChild(left);
      row.appendChild(right);

      els.nextMatchCard.appendChild(title);
      els.nextMatchCard.appendChild(players);
      els.nextMatchCard.appendChild(row);
    }

    function renderStandings(tournament) {
      const standings = computeStandings(tournament);
      els.standingsBody.innerHTML = "";

      if (standings.length === 0) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 7;
        td.className = "rr-empty-td";
        td.textContent = "No teams yet.";
        tr.appendChild(td);
        els.standingsBody.appendChild(tr);
        return;
      }

      for (const row of standings) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${safeText(row.teamName)}</td>
          <td>${row.gp}</td>
          <td>${row.w}</td>
          <td>${row.l}</td>
          <td>${row.pf}</td>
          <td>${row.pa}</td>
          <td>${row.diff}</td>
        `;
        els.standingsBody.appendChild(tr);
      }
    }

    function renderSchedule(tournament) {
      els.scheduleContainer.innerHTML = "";

      if (tournament.schedule.length === 0) {
        const empty = document.createElement("div");
        empty.className = "rr-card rr-card-muted";
        empty.textContent = "No schedule yet. Add at least 2 teams, then click “Generate schedule”.";
        els.scheduleContainer.appendChild(empty);
        return;
      }

      const byRound = new Map();
      for (const match of tournament.schedule) {
        const arr = byRound.get(match.round) || [];
        arr.push(match);
        byRound.set(match.round, arr);
      }

      const rounds = [...byRound.keys()].sort((a, b) => a - b);
      for (const round of rounds) {
        const card = document.createElement("div");
        card.className = "rr-card";

        const title = document.createElement("div");
        title.className = "rr-round-title";
        title.textContent = `Round ${round}`;
        card.appendChild(title);

        const tableWrap = document.createElement("div");
        tableWrap.className = "rr-table-wrap";
        const table = document.createElement("table");
        table.className = "rr-table";
        table.innerHTML = `
          <thead>
            <tr>
              <th>Match</th>
              <th class="rr-col-score">A</th>
              <th class="rr-col-score">B</th>
              <th>Status</th>
              <th></th>
            </tr>
          </thead>
          <tbody></tbody>
        `;

        const tbody = table.querySelector("tbody");
        for (const match of byRound.get(round)) {
          const id = matchIdFor(match);
          const res = tournament.results[id];
          const aName = teamNameById(tournament, match.aId);
          const bName = teamNameById(tournament, match.bId);

          const tr = document.createElement("tr");
          const status = res ? "Played" : "Unplayed";

          const aInputId = `score-a-${id.replaceAll(":", "-")}`;
          const bInputId = `score-b-${id.replaceAll(":", "-")}`;
          tr.innerHTML = `
            <td><strong>${safeText(aName)}</strong> vs <strong>${safeText(bName)}</strong></td>
            <td class="rr-col-score"><input id="${aInputId}" class="rr-score" type="number" inputmode="numeric" value="${res ? res.aScore : ""}" placeholder="0"></td>
            <td class="rr-col-score"><input id="${bInputId}" class="rr-score" type="number" inputmode="numeric" value="${res ? res.bScore : ""}" placeholder="0"></td>
            <td>${status}</td>
            <td class="rr-actions-cell"></td>
          `;

          const actionsCell = tr.querySelector(".rr-actions-cell");
          const saveBtn = document.createElement("button");
          saveBtn.className = "rr-btn rr-btn-primary rr-btn-sm";
          saveBtn.textContent = "Save";
          saveBtn.addEventListener("click", () => {
            const aEl = document.getElementById(aInputId);
            const bEl = document.getElementById(bInputId);
            tournament.results[id] = {
              aScore: clampInt(aEl.value, 0),
              bScore: clampInt(bEl.value, 0),
              completedAt: nowIso(),
            };
            persistTournament(tournament);
            rerender();
          });

          const clearBtn = document.createElement("button");
          clearBtn.className = "rr-btn rr-btn-danger rr-btn-sm";
          clearBtn.textContent = "Clear";
          clearBtn.addEventListener("click", () => {
            delete tournament.results[id];
            persistTournament(tournament);
            rerender();
          });

          actionsCell.appendChild(saveBtn);
          actionsCell.appendChild(clearBtn);

          tbody.appendChild(tr);
        }

        tableWrap.appendChild(table);
        card.appendChild(tableWrap);
        els.scheduleContainer.appendChild(card);
      }
    }

    function rerender() {
      const tournament = state.tournament;
      if (!tournament) return;
      renderTournamentHeader(tournament);
      renderTeams(tournament);
      renderNextMatch(tournament);
      renderStandings(tournament);
      renderSchedule(tournament);
    }

    // ---------- Events ----------
    els.syncGistId.addEventListener("input", () => {
      sync.gistId = els.syncGistId.value.trim();
      saveSyncSettings(sync);
      applySyncSettingsToUI();
      configureLiveUpdates();
    });
    els.syncFileName.addEventListener("input", () => {
      sync.fileName = els.syncFileName.value.trim() || "pitch.json";
      saveSyncSettings(sync);
      applySyncSettingsToUI();
    });
    els.syncToken.addEventListener("input", () => {
      sync.token = els.syncToken.value.trim();
      saveSyncSettings(sync);
      applySyncSettingsToUI();
      configureLiveUpdates();
    });
    els.syncInterval.addEventListener("input", () => {
      sync.intervalSec = Math.max(3, clampInt(els.syncInterval.value, 8));
      saveSyncSettings(sync);
      applySyncSettingsToUI();
      configureLiveUpdates();
    });
    els.syncLiveToggle.addEventListener("change", () => {
      sync.live = Boolean(els.syncLiveToggle.checked);
      saveSyncSettings(sync);
      applySyncSettingsToUI();
      configureLiveUpdates();
    });
    els.syncPullBtn.addEventListener("click", async () => {
      try {
        setSyncStatus("Pulling from GitHub...");
        await syncPull();
        setSyncStatus("Pulled successfully.");
      } catch (e) {
        setSyncStatus(`Pull failed: ${safeText(e?.message || e)}`);
        alert(`Pull failed:\n\n${safeText(e?.message || e)}`);
      }
    });
    els.syncPushBtn.addEventListener("click", async () => {
      try {
        setSyncStatus("Pushing to GitHub...");
        await syncPush();
        setSyncStatus("Pushed successfully.");
      } catch (e) {
        setSyncStatus(`Push failed: ${safeText(e?.message || e)}`);
        alert(`Push failed:\n\n${safeText(e?.message || e)}`);
      }
    });
    els.syncCreateBtn.addEventListener("click", async () => {
      try {
        setSyncStatus("Creating gist...");
        await syncCreateGist();
        setSyncStatus("Gist created.");
      } catch (e) {
        setSyncStatus(`Create failed: ${safeText(e?.message || e)}`);
        alert(`Create gist failed:\n\n${safeText(e?.message || e)}`);
      }
    });

    els.tournamentName.addEventListener("input", () => {
      const t = state.tournament;
      if (!t) return;
      t.name = els.tournamentName.value;
      persistTournament(t);
      renderTournamentHeader(t);
    });

    els.addTeamBtn.addEventListener("click", () => {
      const t = state.tournament;
      if (!t) return;
      t.teams.push({ id: uid(), name: `Team ${t.teams.length + 1}`, players: [] });
      // If teams change, schedule/results might be invalid. Clear them.
      t.schedule = [];
      t.results = {};
      persistTournament(t);
      rerender();
    });

    els.generateBtn.addEventListener("click", () => {
      const t = state.tournament;
      if (!t) return;

      const ids = t.teams.map(team => team.id);
      if (ids.length < 2) {
        alert("Add at least 2 teams to generate a round robin schedule.");
        return;
      }

      t.schedule = generateRoundRobin(ids);
      t.results = {};
      persistTournament(t);
      rerender();
    });

    els.resetResultsBtn.addEventListener("click", () => {
      const t = state.tournament;
      if (!t) return;
      t.results = {};
      persistTournament(t);
      rerender();
    });

    applySyncSettingsToUI();
    configureLiveUpdates();
    rerender();
  </script>
</body>
</html>

