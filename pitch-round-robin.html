<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Round robin board for a Pitch tournament.">
  <link rel="stylesheet" href="style.css">
  <title>Pitch</title>
</head>
<body class="pitch-theme">
  <div class="page">
    <nav class="top-nav">
      <a class="logo" href="index.html"><img src="dutchgif.gif" alt="dutch" class="logo-gif"></a>
      <div class="tab-links">
        <a class="tab" href="index.html">Home</a>
        <a class="tab active" href="pitch-round-robin.html">Pitch</a>
      </div>
    </nav>

    <main class="content">
      <section class="section">
        <img class="pitch-hero-cards" src="assets/cards.svg" alt="" aria-hidden="true">
        <header class="page-heading">
          <h1 class="pitch-title">
            Pitch
            <span class="pitch-suits" aria-hidden="true">
              <span class="pitch-suit pitch-suit-spade">♠</span>
              <span class="pitch-suit pitch-suit-heart">♥</span>
              <span class="pitch-suit pitch-suit-diamond">♦</span>
              <span class="pitch-suit pitch-suit-club">♣</span>
            </span>
          </h1>
        </header>
        <p class="lead">Enter teams + players, auto-generate a round robin schedule, and record scores. Everything saves locally in your browser.</p>
      </section>

      <section class="section">
        <div class="rr-row rr-row-wrap rr-row-gap rr-between">
          <div>
            <h2 class="rr-h2">Teams</h2>
            <p class="rr-hint">Add teams, then click “Generate schedule”. Players are optional.</p>
          </div>
          <div class="rr-row rr-actions">
            <button id="addTeamBtn" class="rr-btn">Add team</button>
            <button id="generateBtn" class="rr-btn rr-btn-primary">Generate schedule</button>
            <button id="resetResultsBtn" class="rr-btn rr-btn-warn">Reset results</button>
          </div>
        </div>

        <div id="teamsContainer" class="rr-team-list"></div>
      </section>

      <section class="section">
        <div class="rr-row rr-between rr-row-wrap rr-row-gap">
          <div>
            <h2 class="rr-h2">Next match</h2>
            <p class="rr-hint">The next unplayed matchup in the schedule.</p>
          </div>
        </div>

        <div id="nextMatchCard" class="rr-card rr-card-muted">
          <div class="rr-hint">Generate a schedule to see the next matchup.</div>
        </div>
      </section>

      <section class="section">
        <div class="rr-row rr-between rr-row-wrap rr-row-gap">
          <div>
            <h2 class="rr-h2">Standings</h2>
            <p class="rr-hint">Wins/Losses are based on recorded match scores.</p>
          </div>
        </div>

        <div class="rr-table-wrap">
          <table class="rr-table" id="standingsTable">
            <thead>
              <tr>
                <th>Team</th>
                <th>GP</th>
                <th>W</th>
                <th>L</th>
                <th>PF</th>
                <th>PA</th>
                <th>Diff</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="section">
        <div class="rr-row rr-between rr-row-wrap rr-row-gap">
          <div>
            <h2 class="rr-h2">Schedule + Scores</h2>
            <p class="rr-hint">Enter scores per matchup. Ties are allowed (no win/loss recorded).</p>
          </div>
        </div>

        <div id="scheduleContainer"></div>
      </section>

      <!-- Host-only / one-time setup. Kept at bottom and collapsed. -->
      <section class="section rr-admin-section">
        <details class="rr-admin">
          <summary class="rr-admin__summary">Init (host only)</summary>
          <div class="rr-admin__body">
            <p class="rr-hint">Optional: enable a shared board across phones. Otherwise, everything stays on this device.</p>
            <div class="rr-row rr-between rr-row-wrap rr-row-gap">
              <p id="syncStatus" class="rr-hint" style="margin:0;">Shared board not configured.</p>
              <div class="rr-row rr-actions">
                <button id="syncSetupBtn" class="rr-btn rr-btn-primary">Setup shared board</button>
              </div>
            </div>
          </div>
        </details>
      </section>
    </main>

    <footer class="footer">
      <p>© 2026</p>
    </footer>
  </div>

  <!-- Shared board setup (host-only) -->
  <div id="syncModal" class="rr-modal" aria-hidden="true">
    <div class="rr-modal__panel" role="dialog" aria-modal="true" aria-labelledby="syncModalTitle">
      <div class="rr-modal__header">
        <div>
          <div id="syncModalTitle" class="rr-modal__title">Enable shared board</div>
          <div class="rr-hint">Host-only setup.</div>
        </div>
        <button id="syncModalCloseBtn" class="rr-btn rr-btn-sm">Close</button>
      </div>

      <div class="rr-modal__body">
        <div class="rr-card rr-card-muted">
          <p class="rr-hint" style="margin-top:0;">
            Writing requires a GitHub personal access token with permission to edit Gists. GitHub does not allow this to be auto-generated from typing team names.
          </p>
        </div>

        <div class="rr-field">
          <label for="syncTokenModal">GitHub token (stored on this device)</label>
          <input id="syncTokenModal" type="password" placeholder="ghp_..." autocomplete="off">
        </div>

        <div class="rr-field">
          <label for="syncGistIdModal">Board ID (leave blank to create)</label>
          <input id="syncGistIdModal" type="text" placeholder="e.g. 0123456789abcdef..." autocomplete="off">
        </div>

        <div class="rr-field">
          <label for="syncFileNameModal">File name</label>
          <input id="syncFileNameModal" type="text" placeholder="pitch.json" autocomplete="off" value="pitch.json">
        </div>
      </div>

      <div class="rr-modal__footer">
        <button id="syncDisableBtn" class="rr-btn rr-btn-danger">Disable</button>
        <div class="rr-modal__footer-spacer"></div>
        <button id="syncUseExistingBtn" class="rr-btn">Use existing</button>
        <button id="syncCreateAndEnableBtn" class="rr-btn rr-btn-primary">Create + enable</button>
      </div>
    </div>
  </div>

  <script>
    /**
     * Pitch Round Robin — single-file, no deps.
     * Data persists in localStorage under STORAGE_KEY.
     */
    const STORAGE_KEY_V1 = "pitch_round_robin:v1";
    const STORAGE_KEY = "pitch_round_robin:v2";
    const SYNC_KEY = "pitch_round_robin:sync:v1";

    function nowIso() {
      return new Date().toISOString();
    }

    function uid() {
      // Short, deterministic-enough local id
      return Math.random().toString(36).slice(2, 10) + "-" + Date.now().toString(36);
    }

    function clampInt(val, fallback = 0) {
      if (val === "" || val === null || typeof val === "undefined") return fallback;
      const n = Number(val);
      if (!Number.isFinite(n)) return fallback;
      return Math.trunc(n);
    }

    function safeText(s) {
      return (s ?? "").toString();
    }

    function parsePlayers(str) {
      return safeText(str)
        .split(/[\n,]+/g)
        .map(s => s.trim())
        .filter(Boolean)
        .slice(0, 12);
    }

    function formatPlayers(players) {
      return (players || []).join(", ");
    }

    function migrateV1ToV2(v1) {
      if (!v1 || typeof v1 !== "object") return null;
      const tournaments = Array.isArray(v1.tournaments) ? v1.tournaments : [];
      if (tournaments.length === 0) return null;
      const active = v1.activeId ? (tournaments.find(t => t.id === v1.activeId) || null) : null;
      const picked = active || tournaments[0] || null;
      if (!picked) return null;
      return { tournament: picked };
    }

    function loadState() {
      try {
        const rawV2 = localStorage.getItem(STORAGE_KEY);
        if (rawV2) {
          const parsed = JSON.parse(rawV2);
          if (parsed && typeof parsed === "object" && parsed.tournament && typeof parsed.tournament === "object") {
            return { tournament: parsed.tournament };
          }
        }

        const rawV1 = localStorage.getItem(STORAGE_KEY_V1);
        if (rawV1) {
          const parsedV1 = JSON.parse(rawV1);
          const migrated = migrateV1ToV2(parsedV1);
          if (migrated) return migrated;
        }

        return { tournament: defaultTournament() };
      } catch {
        return { tournament: defaultTournament() };
      }
    }

    function saveState(state) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function loadSyncSettings() {
      try {
        const raw = localStorage.getItem(SYNC_KEY);
        if (!raw) {
          return { gistId: "", token: "", fileName: "pitch.json", lastRemoteUpdatedAt: "" };
        }
        const parsed = JSON.parse(raw);
        return {
          gistId: safeText(parsed.gistId || ""),
          token: safeText(parsed.token || ""),
          fileName: safeText(parsed.fileName || "pitch.json") || "pitch.json",
          lastRemoteUpdatedAt: safeText(parsed.lastRemoteUpdatedAt || ""),
        };
      } catch {
        return { gistId: "", token: "", fileName: "pitch.json", lastRemoteUpdatedAt: "" };
      }
    }

    function saveSyncSettings(settings) {
      localStorage.setItem(SYNC_KEY, JSON.stringify(settings));
    }

    function defaultTournament() {
      return {
        id: uid(),
        name: "Pitch Round Robin",
        createdAt: nowIso(),
        updatedAt: nowIso(),
        teams: [
          { id: uid(), name: "Team A", players: ["Player 1", "Player 2"] },
          { id: uid(), name: "Team B", players: ["Player 3", "Player 4"] },
        ],
        schedule: [],
        results: {}, // matchId -> { aScore, bScore, completedAt }
      };
    }

    function teamNameById(tournament, teamId) {
      return tournament.teams.find(t => t.id === teamId)?.name || "Unknown";
    }

    function matchIdFor(match) {
      return `${match.round}:${match.aId}:${match.bId}`;
    }

    // Standard circle method (a.k.a. Berger tables)
    function generateRoundRobin(teamIds) {
      const ids = [...teamIds];
      if (ids.length < 2) return [];
      if (ids.length % 2 === 1) ids.push(null); // BYE

      const n = ids.length;
      const rounds = n - 1;
      const perRound = n / 2;
      let arr = [...ids];
      const schedule = [];

      for (let r = 0; r < rounds; r++) {
        for (let i = 0; i < perRound; i++) {
          const left = arr[i];
          const right = arr[n - 1 - i];
          if (left === null || right === null) continue;

          // Alternate home/away each round for a bit of fairness
          const swap = (r % 2 === 1) && (i === 0);
          const aId = swap ? right : left;
          const bId = swap ? left : right;

          schedule.push({ round: r + 1, aId, bId });
        }

        // Rotate all but the first element
        // [0, 1, 2, 3, 4, 5] -> [0, 5, 1, 2, 3, 4]
        arr = [arr[0], arr[n - 1], ...arr.slice(1, n - 1)];
      }

      return schedule;
    }

    function computeStandings(tournament) {
      const base = new Map();
      for (const team of tournament.teams) {
        base.set(team.id, {
          teamId: team.id,
          teamName: team.name,
          gp: 0,
          w: 0,
          l: 0,
          pf: 0,
          pa: 0,
        });
      }

      for (const match of tournament.schedule) {
        const id = matchIdFor(match);
        const res = tournament.results[id];
        if (!res) continue;

        const a = base.get(match.aId);
        const b = base.get(match.bId);
        if (!a || !b) continue;

        a.gp += 1;
        b.gp += 1;
        a.pf += res.aScore;
        a.pa += res.bScore;
        b.pf += res.bScore;
        b.pa += res.aScore;

        if (res.aScore > res.bScore) {
          a.w += 1;
          b.l += 1;
        } else if (res.bScore > res.aScore) {
          b.w += 1;
          a.l += 1;
        }
      }

      const rows = [...base.values()].map(r => ({ ...r, diff: r.pf - r.pa }));
      rows.sort((x, y) => {
        if (y.w !== x.w) return y.w - x.w;
        if (y.diff !== x.diff) return y.diff - x.diff;
        if (y.pf !== x.pf) return y.pf - x.pf;
        return x.teamName.localeCompare(y.teamName);
      });
      return rows;
    }

    function nextMatch(tournament) {
      for (const match of tournament.schedule) {
        const id = matchIdFor(match);
        if (!tournament.results[id]) return match;
      }
      return null;
    }

    // ---------- UI ----------
    const els = {
      syncStatus: document.getElementById("syncStatus"),
      syncSetupBtn: document.getElementById("syncSetupBtn"),
      syncModal: document.getElementById("syncModal"),
      syncModalCloseBtn: document.getElementById("syncModalCloseBtn"),
      syncTokenModal: document.getElementById("syncTokenModal"),
      syncGistIdModal: document.getElementById("syncGistIdModal"),
      syncFileNameModal: document.getElementById("syncFileNameModal"),
      syncUseExistingBtn: document.getElementById("syncUseExistingBtn"),
      syncCreateAndEnableBtn: document.getElementById("syncCreateAndEnableBtn"),
      syncDisableBtn: document.getElementById("syncDisableBtn"),
      addTeamBtn: document.getElementById("addTeamBtn"),
      generateBtn: document.getElementById("generateBtn"),
      resetResultsBtn: document.getElementById("resetResultsBtn"),
      teamsContainer: document.getElementById("teamsContainer"),
      nextMatchCard: document.getElementById("nextMatchCard"),
      standingsBody: document.querySelector("#standingsTable tbody"),
      scheduleContainer: document.getElementById("scheduleContainer"),
    };

    let state = loadState();
    let sync = loadSyncSettings();
    let autoPushTimer = null;
    let autoPushPending = false;
    let autoPushInFlight = false;

    if (!state.tournament) {
      state.tournament = defaultTournament();
      saveState(state);
    }

    function persistTournament(tournament) {
      tournament.updatedAt = nowIso();
      state.tournament = tournament;
      saveState(state);
      scheduleAutoPush({ reason: "tournament_change" });
    }

    function setSyncStatus(msg) {
      els.syncStatus.textContent = msg;
    }

    function applySyncStatus() {
      const hasGist = Boolean(sync.gistId);
      const hasToken = Boolean(sync.token);
      if (!hasGist) {
        setSyncStatus("Shared board not configured.");
        return;
      }
      const remoteText = sync.lastRemoteUpdatedAt ? `Last remote update: ${new Date(sync.lastRemoteUpdatedAt).toLocaleString()}` : "Remote not fetched yet.";
      const writeText = hasToken ? "Write: enabled" : "Write: disabled";
      setSyncStatus(`Board: ${sync.gistId} · ${writeText} · ${remoteText}`);
    }

    function githubHeaders(token) {
      const headers = {
        "Accept": "application/vnd.github+json",
      };
      if (token) headers["Authorization"] = `Bearer ${token}`;
      return headers;
    }

    async function fetchGist(gistId, token) {
      const res = await fetch(`https://api.github.com/gists/${encodeURIComponent(gistId)}`, {
        method: "GET",
        headers: githubHeaders(token),
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GitHub GET gist failed (${res.status}): ${text}`);
      }
      return await res.json();
    }

    function extractGistFileContent(gistJson, fileName) {
      const files = gistJson?.files || {};
      const file = files[fileName] || null;
      if (!file) {
        const available = Object.keys(files);
        throw new Error(`Gist does not contain "${fileName}". Available: ${available.length ? available.join(", ") : "(none)"}`);
      }
      const content = file.content;
      if (typeof content !== "string") throw new Error(`Gist file "${fileName}" has no readable content.`);
      return content;
    }

    function validateRemoteState(remote) {
      if (!remote || typeof remote !== "object") return false;
      // v2: { tournament: {...} }
      if (remote.tournament && typeof remote.tournament === "object") return true;
      // v1: { activeId, tournaments: [...] }
      if (Array.isArray(remote.tournaments)) return true;
      return false;
    }

    function coerceRemoteToV2(remote) {
      if (remote?.tournament && typeof remote.tournament === "object") {
        return { tournament: remote.tournament };
      }
      const migrated = migrateV1ToV2(remote);
      if (migrated) return migrated;
      return { tournament: defaultTournament() };
    }

    async function syncPull({ quiet = false } = {}) {
      if (!sync.gistId) {
        if (!quiet) alert("Shared board is not configured.");
        return;
      }
      const gist = await fetchGist(sync.gistId, sync.token);
      const content = extractGistFileContent(gist, sync.fileName || "pitch.json");
      const remote = JSON.parse(content);
      if (!validateRemoteState(remote)) throw new Error("Remote file JSON is not a valid Pitch state object.");

      state = coerceRemoteToV2(remote);
      saveState(state);

      sync.lastRemoteUpdatedAt = safeText(gist.updated_at || "");
      saveSyncSettings(sync);
      rerender();
      applySyncStatus();
    }

    async function syncPush() {
      if (!sync.gistId) {
        alert("Shared board is not configured.");
        return;
      }
      if (!sync.token) {
        alert("A GitHub token with gist permission is required to write to the shared board.");
        return;
      }

      // Fetch remote first for conflict detection
      const gist = await fetchGist(sync.gistId, sync.token);
      const remoteUpdatedAt = safeText(gist.updated_at || "");
      if (sync.lastRemoteUpdatedAt && remoteUpdatedAt && sync.lastRemoteUpdatedAt !== remoteUpdatedAt) {
        const proceed = confirm("Remote gist changed since your last pull. Push anyway (may overwrite remote changes)?");
        if (!proceed) return;
      }

      const fileName = sync.fileName || "pitch.json";
      const body = {
        files: {
          [fileName]: { content: JSON.stringify(state, null, 2) },
        },
      };

      const res = await fetch(`https://api.github.com/gists/${encodeURIComponent(sync.gistId)}`, {
        method: "PATCH",
        headers: {
          ...githubHeaders(sync.token),
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GitHub PATCH gist failed (${res.status}): ${text}`);
      }

      const updated = await res.json();
      sync.lastRemoteUpdatedAt = safeText(updated.updated_at || "");
      saveSyncSettings(sync);
      applySyncStatus();
    }

    async function syncCreateGist() {
      if (!sync.token) {
        alert("A GitHub token with gist permission is required to create a shared board.");
        return;
      }
      const fileName = sync.fileName || "pitch.json";
      const body = {
        description: "Pitch tournament data (round robin board)",
        public: false,
        files: {
          [fileName]: { content: JSON.stringify(state, null, 2) },
        },
      };

      const res = await fetch("https://api.github.com/gists", {
        method: "POST",
        headers: {
          ...githubHeaders(sync.token),
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GitHub POST gist failed (${res.status}): ${text}`);
      }

      const created = await res.json();
      sync.gistId = safeText(created.id || "");
      sync.lastRemoteUpdatedAt = safeText(created.updated_at || "");
      saveSyncSettings(sync);
      applySyncStatus();
      alert(`Shared board created. Share this Board ID:\n\n${sync.gistId}`);
    }

    function clearLiveTimer() {
      // polling removed (event-driven sync only)
    }

    function configureLiveUpdates() {
      // polling removed (event-driven sync only)
    }

    function openSyncModal() {
      els.syncTokenModal.value = sync.token || "";
      els.syncGistIdModal.value = sync.gistId || "";
      els.syncFileNameModal.value = sync.fileName || "pitch.json";
      els.syncModal.setAttribute("aria-hidden", "false");
      els.syncModal.classList.add("rr-modal--open");
    }

    function closeSyncModal() {
      els.syncModal.setAttribute("aria-hidden", "true");
      els.syncModal.classList.remove("rr-modal--open");
    }

    function scheduleAutoPush({ delayMs = 600 } = {}) {
      if (!sync.gistId) return; // nothing to push to
      if (!sync.token) return;  // can't write without token
      if (autoPushTimer) clearTimeout(autoPushTimer);
      autoPushTimer = setTimeout(() => {
        autoPushTimer = null;
        autoSyncPushLatest().catch(() => {
          // status already updated inside
        });
      }, delayMs);
    }

    async function autoSyncPushLatest() {
      if (!sync.gistId || !sync.token) return;
      if (autoPushInFlight) {
        autoPushPending = true;
        return;
      }
      autoPushInFlight = true;
      autoPushPending = false;
      try {
        // Fetch remote and only push if local is newer (simple conflict avoidance)
        const gist = await fetchGist(sync.gistId, sync.token);
        const remoteUpdatedAt = safeText(gist.updated_at || "");

        let remoteState = null;
        try {
          const content = extractGistFileContent(gist, sync.fileName || "pitch.json");
          remoteState = coerceRemoteToV2(JSON.parse(content));
        } catch {
          remoteState = null;
        }

        const localUpdated = safeText(state?.tournament?.updatedAt || "");
        const remoteUpdated = safeText(remoteState?.tournament?.updatedAt || "");

        // If remote looks newer, adopt it (auto-pull) and skip pushing
        if (remoteUpdated && (!localUpdated || new Date(remoteUpdated) > new Date(localUpdated))) {
          state = remoteState;
          saveState(state);
          sync.lastRemoteUpdatedAt = remoteUpdatedAt;
          saveSyncSettings(sync);
          rerender();
          applySyncStatus();
          return;
        }

        // Otherwise push local
        const fileName = sync.fileName || "pitch.json";
        const body = {
          files: {
            [fileName]: { content: JSON.stringify(state, null, 2) },
          },
        };
        const res = await fetch(`https://api.github.com/gists/${encodeURIComponent(sync.gistId)}`, {
          method: "PATCH",
          headers: {
            ...githubHeaders(sync.token),
            "Content-Type": "application/json",
          },
          body: JSON.stringify(body),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`Auto-sync failed (${res.status}): ${text}`);
        }
        const updated = await res.json();
        sync.lastRemoteUpdatedAt = safeText(updated.updated_at || "");
        saveSyncSettings(sync);
        applySyncStatus();
      } catch (e) {
        setSyncStatus(`Sync error: ${safeText(e?.message || e)}`);
      } finally {
        autoPushInFlight = false;
        if (autoPushPending) {
          autoPushPending = false;
          scheduleAutoPush({ delayMs: 600 });
        }
      }
    }

    function renderTeams(tournament) {
      els.teamsContainer.innerHTML = "";
      if (tournament.teams.length === 0) {
        const empty = document.createElement("div");
        empty.className = "rr-card rr-card-muted";
        empty.textContent = "No teams yet. Click “Add team”.";
        els.teamsContainer.appendChild(empty);
        return;
      }

      tournament.teams.forEach((team, idx) => {
        const card = document.createElement("div");
        card.className = "rr-card";

        const top = document.createElement("div");
        top.className = "rr-row rr-between rr-row-gap rr-row-wrap";

        const left = document.createElement("div");
        left.className = "rr-grow";

        const nameLabel = document.createElement("label");
        nameLabel.textContent = `Team ${idx + 1} name`;
        nameLabel.setAttribute("for", `team-name-${team.id}`);
        const nameInput = document.createElement("input");
        nameInput.id = `team-name-${team.id}`;
        nameInput.type = "text";
        nameInput.value = team.name || "";
        nameInput.placeholder = "Team name";
        nameInput.autocomplete = "off";
        nameInput.addEventListener("input", () => {
          team.name = nameInput.value;
          persistTournament(tournament);
          renderStandings(tournament);
          renderNextMatch(tournament);
          renderSchedule(tournament);
        });

        left.appendChild(nameLabel);
        left.appendChild(nameInput);

        const right = document.createElement("div");
        right.className = "rr-row rr-actions";

        const removeBtn = document.createElement("button");
        removeBtn.className = "rr-btn rr-btn-danger";
        removeBtn.textContent = "Remove";
        removeBtn.addEventListener("click", () => {
          tournament.teams = tournament.teams.filter(t => t.id !== team.id);
          // If teams change, schedule/results might be invalid. Clear them.
          tournament.schedule = [];
          tournament.results = {};
          persistTournament(tournament);
          rerender();
        });

        right.appendChild(removeBtn);
        top.appendChild(left);
        top.appendChild(right);

        const playersLabel = document.createElement("label");
        playersLabel.textContent = "Players (comma or newline separated)";
        playersLabel.setAttribute("for", `team-players-${team.id}`);
        const players = document.createElement("textarea");
        players.id = `team-players-${team.id}`;
        players.rows = 2;
        players.placeholder = "e.g. Alice, Bob";
        players.value = formatPlayers(team.players);
        players.addEventListener("input", () => {
          team.players = parsePlayers(players.value);
          persistTournament(tournament);
          renderNextMatch(tournament);
        });

        card.appendChild(top);
        card.appendChild(playersLabel);
        card.appendChild(players);

        els.teamsContainer.appendChild(card);
      });
    }

    function renderNextMatch(tournament) {
      const match = nextMatch(tournament);
      els.nextMatchCard.innerHTML = "";

      if (!match) {
        const done = document.createElement("div");
        done.className = "rr-hint";
        done.textContent = tournament.schedule.length ? "All matches completed." : "Generate a schedule to see the next matchup.";
        els.nextMatchCard.className = "rr-card rr-card-muted";
        els.nextMatchCard.appendChild(done);
        return;
      }

      els.nextMatchCard.className = "rr-card";

      const aTeam = tournament.teams.find(t => t.id === match.aId);
      const bTeam = tournament.teams.find(t => t.id === match.bId);
      const title = document.createElement("div");
      title.className = "rr-next-title";
      title.textContent = `Round ${match.round}: ${aTeam?.name || "Unknown"} vs ${bTeam?.name || "Unknown"}`;

      const players = document.createElement("div");
      players.className = "rr-hint";
      const aPlayers = (aTeam?.players || []).length ? ` (${(aTeam.players || []).join(", ")})` : "";
      const bPlayers = (bTeam?.players || []).length ? ` (${(bTeam.players || []).join(", ")})` : "";
      players.textContent = `${aTeam?.name || "Unknown"}${aPlayers} · ${bTeam?.name || "Unknown"}${bPlayers}`;

      const row = document.createElement("div");
      row.className = "rr-row rr-row-wrap rr-row-gap rr-between";

      const left = document.createElement("div");
      left.className = "rr-row rr-row-wrap rr-row-gap rr-grow";

      const aField = document.createElement("div");
      aField.className = "rr-field";
      const aLabel = document.createElement("label");
      aLabel.textContent = `${aTeam?.name || "Team A"} score`;
      const aScore = document.createElement("input");
      aScore.type = "number";
      aScore.inputMode = "numeric";
      aScore.placeholder = "0";
      aScore.value = "";
      aField.appendChild(aLabel);
      aField.appendChild(aScore);

      const bField = document.createElement("div");
      bField.className = "rr-field";
      const bLabel = document.createElement("label");
      bLabel.textContent = `${bTeam?.name || "Team B"} score`;
      const bScore = document.createElement("input");
      bScore.type = "number";
      bScore.inputMode = "numeric";
      bScore.placeholder = "0";
      bScore.value = "";
      bField.appendChild(bLabel);
      bField.appendChild(bScore);

      left.appendChild(aField);
      left.appendChild(bField);

      const right = document.createElement("div");
      right.className = "rr-row rr-actions";

      const saveBtn = document.createElement("button");
      saveBtn.className = "rr-btn rr-btn-primary";
      saveBtn.textContent = "Record result";
      saveBtn.addEventListener("click", () => {
        const id = matchIdFor(match);
        tournament.results[id] = {
          aScore: clampInt(aScore.value, 0),
          bScore: clampInt(bScore.value, 0),
          completedAt: nowIso(),
        };
        persistTournament(tournament);
        rerender();
      });

      right.appendChild(saveBtn);

      row.appendChild(left);
      row.appendChild(right);

      els.nextMatchCard.appendChild(title);
      els.nextMatchCard.appendChild(players);
      els.nextMatchCard.appendChild(row);
    }

    function renderStandings(tournament) {
      const standings = computeStandings(tournament);
      els.standingsBody.innerHTML = "";

      if (standings.length === 0) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 7;
        td.className = "rr-empty-td";
        td.textContent = "No teams yet.";
        tr.appendChild(td);
        els.standingsBody.appendChild(tr);
        return;
      }

      for (const row of standings) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${safeText(row.teamName)}</td>
          <td>${row.gp}</td>
          <td>${row.w}</td>
          <td>${row.l}</td>
          <td>${row.pf}</td>
          <td>${row.pa}</td>
          <td>${row.diff}</td>
        `;
        els.standingsBody.appendChild(tr);
      }
    }

    function renderSchedule(tournament) {
      els.scheduleContainer.innerHTML = "";

      if (tournament.schedule.length === 0) {
        const empty = document.createElement("div");
        empty.className = "rr-card rr-card-muted";
        empty.textContent = "No schedule yet. Add at least 2 teams, then click “Generate schedule”.";
        els.scheduleContainer.appendChild(empty);
        return;
      }

      const byRound = new Map();
      for (const match of tournament.schedule) {
        const arr = byRound.get(match.round) || [];
        arr.push(match);
        byRound.set(match.round, arr);
      }

      const rounds = [...byRound.keys()].sort((a, b) => a - b);
      for (const round of rounds) {
        const card = document.createElement("div");
        card.className = "rr-card";

        const title = document.createElement("div");
        title.className = "rr-round-title";
        title.textContent = `Round ${round}`;
        card.appendChild(title);

        const tableWrap = document.createElement("div");
        tableWrap.className = "rr-table-wrap";
        const table = document.createElement("table");
        table.className = "rr-table";
        table.innerHTML = `
          <thead>
            <tr>
              <th>Match</th>
              <th class="rr-col-score">A</th>
              <th class="rr-col-score">B</th>
              <th>Status</th>
              <th></th>
            </tr>
          </thead>
          <tbody></tbody>
        `;

        const tbody = table.querySelector("tbody");
        for (const match of byRound.get(round)) {
          const id = matchIdFor(match);
          const res = tournament.results[id];
          const aName = teamNameById(tournament, match.aId);
          const bName = teamNameById(tournament, match.bId);

          const tr = document.createElement("tr");
          const status = res ? "Played" : "Unplayed";

          const aInputId = `score-a-${id.replaceAll(":", "-")}`;
          const bInputId = `score-b-${id.replaceAll(":", "-")}`;
          tr.innerHTML = `
            <td><strong>${safeText(aName)}</strong> vs <strong>${safeText(bName)}</strong></td>
            <td class="rr-col-score"><input id="${aInputId}" class="rr-score" type="number" inputmode="numeric" value="${res ? res.aScore : ""}" placeholder="0"></td>
            <td class="rr-col-score"><input id="${bInputId}" class="rr-score" type="number" inputmode="numeric" value="${res ? res.bScore : ""}" placeholder="0"></td>
            <td>${status}</td>
            <td class="rr-actions-cell"></td>
          `;

          const actionsCell = tr.querySelector(".rr-actions-cell");
          const saveBtn = document.createElement("button");
          saveBtn.className = "rr-btn rr-btn-primary rr-btn-sm";
          saveBtn.textContent = "Save";
          saveBtn.addEventListener("click", () => {
            const aEl = document.getElementById(aInputId);
            const bEl = document.getElementById(bInputId);
            tournament.results[id] = {
              aScore: clampInt(aEl.value, 0),
              bScore: clampInt(bEl.value, 0),
              completedAt: nowIso(),
            };
            persistTournament(tournament);
            rerender();
          });

          const clearBtn = document.createElement("button");
          clearBtn.className = "rr-btn rr-btn-danger rr-btn-sm";
          clearBtn.textContent = "Clear";
          clearBtn.addEventListener("click", () => {
            delete tournament.results[id];
            persistTournament(tournament);
            rerender();
          });

          actionsCell.appendChild(saveBtn);
          actionsCell.appendChild(clearBtn);

          tbody.appendChild(tr);
        }

        tableWrap.appendChild(table);
        card.appendChild(tableWrap);
        els.scheduleContainer.appendChild(card);
      }
    }

    function rerender() {
      const tournament = state.tournament;
      if (!tournament) return;
      renderTeams(tournament);
      renderNextMatch(tournament);
      renderStandings(tournament);
      renderSchedule(tournament);
    }

    // ---------- Events ----------
    els.syncSetupBtn.addEventListener("click", () => openSyncModal());
    els.syncModalCloseBtn.addEventListener("click", () => closeSyncModal());
    els.syncModal.addEventListener("click", (e) => {
      if (e.target === els.syncModal) closeSyncModal();
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeSyncModal();
    });

    els.syncDisableBtn.addEventListener("click", () => {
      sync = { gistId: "", token: "", fileName: "pitch.json", lastRemoteUpdatedAt: "" };
      saveSyncSettings(sync);
      applySyncStatus();
      closeSyncModal();
    });

    els.syncUseExistingBtn.addEventListener("click", async () => {
      sync.token = els.syncTokenModal.value.trim();
      sync.gistId = els.syncGistIdModal.value.trim();
      sync.fileName = els.syncFileNameModal.value.trim() || "pitch.json";
      saveSyncSettings(sync);
      applySyncStatus();

      if (!sync.gistId) {
        alert("Paste a Board ID, or use Create + enable.");
        return;
      }

      // Pull immediately so everyone starts from the same board
      try {
        await syncPull({ quiet: true });
      } catch (e) {
        setSyncStatus(`Sync setup error: ${safeText(e?.message || e)}`);
      } finally {
        closeSyncModal();
      }
    });

    els.syncCreateAndEnableBtn.addEventListener("click", async () => {
      sync.token = els.syncTokenModal.value.trim();
      sync.gistId = els.syncGistIdModal.value.trim();
      sync.fileName = els.syncFileNameModal.value.trim() || "pitch.json";
      saveSyncSettings(sync);
      applySyncStatus();

      try {
        if (sync.gistId) {
          // Existing board ID provided: just pull and enable
          await syncPull({ quiet: true });
        } else {
          // Create new shared board from current local state
          await syncCreateGist();
        }
        // Push right away to ensure remote exists/has latest
        scheduleAutoPush({ delayMs: 250 });
      } catch (e) {
        setSyncStatus(`Sync setup error: ${safeText(e?.message || e)}`);
        alert(`Sync setup failed:\n\n${safeText(e?.message || e)}`);
      } finally {
        closeSyncModal();
      }
    });

    els.addTeamBtn.addEventListener("click", () => {
      const t = state.tournament;
      if (!t) return;
      t.teams.push({ id: uid(), name: `Team ${t.teams.length + 1}`, players: [] });
      // If teams change, schedule/results might be invalid. Clear them.
      t.schedule = [];
      t.results = {};
      persistTournament(t);
      rerender();
    });

    els.generateBtn.addEventListener("click", () => {
      const t = state.tournament;
      if (!t) return;

      const ids = t.teams.map(team => team.id);
      if (ids.length < 2) {
        alert("Add at least 2 teams to generate a round robin schedule.");
        return;
      }

      t.schedule = generateRoundRobin(ids);
      t.results = {};
      persistTournament(t);
      rerender();
    });

    els.resetResultsBtn.addEventListener("click", () => {
      const t = state.tournament;
      if (!t) return;
      t.results = {};
      persistTournament(t);
      rerender();
    });

    applySyncStatus();
    rerender();

    // Event-driven refresh: when you come back to the tab, pull once.
    window.addEventListener("focus", () => {
      if (!sync.gistId) return;
      syncPull({ quiet: true }).catch(() => {});
    });
  </script>
</body>
</html>

